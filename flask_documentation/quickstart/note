The flask run command can do more than just start the development server.
 By enabling debug mode, the server will automatically reload if code changes, and will show an interactive debugger in the browser
 if an error occurs during a request.
 flask --app hello run --debug

 Use the route() decorator to bind a function to a URL.

Variable Rules
You can add variable sections to a URL by marking sections with <variable_name>. Your function then receives the <variable_name> as a keyword argument.
Optionally, you can use a converter to specify the type of the argument like <converter:variable_name>

from markupsafe import escape

@app.route('/user/<username>')
def show_user_profile(username):
    # show the user profile for that user
    return f'User {escape(username)}'
########################################################################

To build a URL to a specific function, use the url_for() function.
It accepts the name of the function as its first argument and any number of keyword arguments, each corresponding to a variable part of the URL rule.
Unknown variable parts are appended to the URL as query parameters.

from flask import url_for
from flask import Flask
app = Flask(__name__)
@app.route('/')
def index():
    return 'index'

@app.route('/login')
def login():
    return 'login'

@app.route('/user/<username>')
def profile(username):
    return f'{username}\'s profile'

with app.test_request_context():
    print(url_for('index'))
    print(url_for('login'))
    print(url_for('login', next='/'))
    print(url_for('profile', username='John Doe'))

#################################################################

HTTP Methods
Web applications use different HTTP methods when accessing URLs.
You should familiarize yourself with the HTTP methods as you work with Flask. By default, a route only answers to GET requests.
You can use the methods argument of the route() decorator to handle different HTTP methods.

@app.route('/login', methods=['GET', 'POST'])
@app.get('/login')
@app.post('/login')

###################################################################
Static Files
Dynamic web applications also need static files.
That’s usually where the CSS and JavaScript files are coming from.
Ideally your web server is configured to serve them for you, but during development Flask can do that as well.
Just create a folder called static in your package or next to your module and it will be available at /static on the application.

To generate URLs for static files, use the special 'static' endpoint name:
url_for('static', filename='style.css')

##################################################################

To render a template you can use the render_template() method.
All you have to do is provide the name of the template and the variables you want to pass to the template engine as keyword arguments.
 Here’s a simple example of how to render a template:

from flask import render_template
@app.route('/hello/')
@app.route('/hello/<name>')
def hello(name=None):
    return render_template('hello.html', name=name)

###################################################################

The current request method is available by using the method attribute.
To access form data (data transmitted in a POST or PUT request) you can use the form attribute.
 Here is a full example of the two attributes mentioned above:

from flask import request

@app.route('/login', methods=['POST', 'GET'])
def login():
    error = None
    if request.method == 'POST':
        if valid_login(request.form['username'],
                       request.form['password']):
            return log_the_user_in(request.form['username'])
        else:
            error = 'Invalid username/password'
    # the code below is executed if the request method
    # was GET or the credentials were invalid
    return render_template('login.html', error=error)

######################################################################